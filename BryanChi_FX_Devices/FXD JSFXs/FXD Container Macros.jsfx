noindex: true

desc:FXD Containr Macro
import cookdsp.jsfx-inc


slider1:0<0,1>Macro 1
slider2:0<0,1>Macro 2
slider3:0<0,1>Macro 3
slider4:0<0,1>Macro 4
slider5:0<0,1>Macro 5
slider6:0<0,1>Macro 6
slider7:0<0,1>Macro 7
slider8:0<0,1>Macro 8
slider9:0<0,127>Morph 1
slider10:0<0,127>Morph 2
slider11:0<0,127>Morph 3
slider12:0<0,127>Morph 4
slider13:0<0,127>Morph 5
slider14:0<0,127>Morph 6
slider15:0<0,127>Morph 7
slider16:0<0,127>Morph 8
slider17:0<0,1>Automatable Param 1
slider18:0<0,1>Automatable Param 2
slider19:0<0,1>Automatable Param 3
slider20:0<0,1>Automatable Param 4
slider21:0<0,1>Automatable Param 5
slider22:0<0,1>Automatable Param 6
slider23:0<0,1>Automatable Param 7
slider24:0<0,1>Automatable Param 8






in_pin:none
out_pin:none

options:gmem=ContainerMacro



@init 

Cont_ID = gmem[0];
ext_midi_bus = 1;

ext_noinit=1;
is_init = 0;
midiamp = midinote = 0;

midi_bus=Cont_ID+15; // 0-based so 1 = bus 2


//totalTrackount =  gmem[0];
DIY_ID = gmem[1];

//  Follower Gain 
  Mc1.Fol_Gain= 0.7 ; 
  Mc2.Fol_Gain= 0.7 ; 
  Mc3.Fol_Gain= 0.7 ; 
  Mc4.Fol_Gain= 0.7 ; 
  Mc5.Fol_Gain= 0.7 ; 
  Mc6.Fol_Gain= 0.7 ; 
  Mc7.Fol_Gain= 0.7 ; 
  Mc8.Fol_Gain= 0.7 ; 

//LFO Gain auto 
  Mc1.LFO_Gain_Auto= 0 ;
  Mc2.LFO_Gain_Auto= 0 ;
  Mc3.LFO_Gain_Auto= 0 ;
  Mc4.LFO_Gain_Auto= 0 ;
  Mc5.LFO_Gain_Auto= 0 ;
  Mc6.LFO_Gain_Auto= 0 ;
  Mc7.LFO_Gain_Auto= 0 ;
  Mc8.LFO_Gain_Auto= 0 ;

// LFO Spd 
  Mc1.LFO_Spd = 1;
  Mc2.LFO_Spd = 1;
  Mc3.LFO_Spd = 1;
  Mc4.LFO_Spd = 1;
  Mc5.LFO_Spd = 1;
  Mc6.LFO_Spd = 1;
  Mc7.LFO_Spd = 1;
  Mc8.LFO_Spd = 1;
//LFO Spd Auto
  Mc1.LFO_Spd_Auto= 0 ;
  Mc2.LFO_Spd_Auto= 0 ;
  Mc3.LFO_Spd_Auto= 0 ;
  Mc4.LFO_Spd_Auto= 0 ;
  Mc5.LFO_Spd_Auto= 0 ;
  Mc6.LFO_Spd_Auto= 0 ;
  Mc7.LFO_Spd_Auto= 0 ;
  Mc8.LFO_Spd_Auto= 0 ;
//LFO_Len '

  Mc1.LFO_Len = 4;
  Mc2.LFO_Len = 4;
  Mc3.LFO_Len = 4;
  Mc4.LFO_Len = 4;
  Mc5.LFO_Len = 4;
  Mc6.LFO_Len = 4;
  Mc7.LFO_Len = 4;
  Mc8.LFO_Len = 4;
// LGO_Gain 
  Mc1.LFO_Gain = 1;
  Mc2.LFO_Gain = 1;
  Mc3.LFO_Gain = 1;
  Mc4.LFO_Gain = 1;
  Mc5.LFO_Gain = 1;
  Mc6.LFO_Gain = 1;
  Mc7.LFO_Gain = 1;
  Mc8.LFO_Gain = 1;




// SEQ DNom And Leng
  Mc1.SEQ_DNom = 1;
  Mc1.SEQ_Leng = 8;
  Mc2.SEQ_DNom = 1;
  Mc2.SEQ_Leng = 8;
  Mc3.SEQ_DNom = 1;
  Mc3.SEQ_Leng = 8;
  Mc4.SEQ_DNom = 1;
  Mc4.SEQ_Leng = 8;
  Mc5.SEQ_DNom = 1;
  Mc5.SEQ_Leng = 8;
  Mc6.SEQ_DNom = 1;
  Mc6.SEQ_Leng = 8;
  Mc7.SEQ_DNom = 1;
  Mc7.SEQ_Leng = 8;
  Mc8.SEQ_DNom = 1;
  Mc8.SEQ_Leng = 8;





//gmem offsets ------------------------------
//gmem 1 = this track's DIY GUID
//gmem 2 = Selected track's Diy GUID
//gmem 3 = Prm Inst
//gmem 4 = if 1 then user is R-Dragging on prm
         //if 2 then user is adjusting env atk
         //if 3 then user is adjusting env rel
         //if 4.1 then Mod 1 is Env, 4.2 then Mod 2 is Env
        
         
//gmem 5 = Which Macro is user assigning
//gmem 6 = Which Param's mod range is user tweaking 
//gmem 7 = determine Param's value before modulaiton
//gmem 8 =  ? 
//gmem 9 = env1 atk      |  currently adjusted LFO node's value
//gmem 10 = env1 rel
//gmem 11 = env2 atk
//gmem 12 = env2 rel
//etc..24
//gmem 31~38 = Modulation type (Macro or Env)
//gmem 101~108 = send Modulation info back to imgui
//gmem 110 = SEQ Length or Denominator when user is tweaking 
//gmem 111 = SEQ Denominator when user is tweaking
//gmem 112 = step value of currently tweaking step
//gmem 121 ~128 = SEQ 1 ~ 8 Current Pos 
//gmem 1000~2000 = Currently open lfo windows all coordinates for X axis 
//gmem 2000~3000 = same as above, but for Y axis
//gmem 11000+ = parameters' value before modulation 

ModAmt = 1000;
ModAmt2 = 2000;
ModAmt3 = 3000;
ModAmt4 = 4000;
ModAmt5 = 5000;
ModAmt6 = 6000;
ModAmt7 = 7000;
ModAmt8 = 8000;
PsUsed = 100; 
P_OrigV = 11000 ;
SEQ = 20000; // 20001~20048 = Macro1 Seq 1~64
Lfo = 30000;    //30000 ~ 30100 =  LFO Node Properties





function setNode(index, attribute, value) (
   address[index * Node_length + attribute] = value;
);

function getNode(index, attribute) (
   address[index * Node_length + attribute];
);










//------------------------------------------------------------
// TABLE INDEX ------------------------------
// 1,3,5,7,9,11,13,15 = envelope 1~8 's atk
// 2,4,6,8,10,12,14,16 = envelope 1~8 's rel
// 17 ~ 64 = Automatable parameters


function fmod (n, k) (
    n - k * floor(n/k);
  );



Mc1.follow(10);
Mc2.follow(10);
Mc3.follow(10);
Mc4.follow(10);
Mc5.follow(10);
Mc6.follow(10);
Mc7.follow(10);
Mc8.follow(10);

Mc1.Macro = 1;
Mc2.Macro = 2;
Mc3.Macro = 3;
Mc4.Macro = 4;
Mc5.Macro = 5;
Mc6.Macro = 6;
Mc7.Macro = 7;
Mc8.Macro = 8;




Mc1.EnvToImGui = 101;
Mc2.EnvToImGui = 102;
Mc3.EnvToImGui = 103;
Mc4.EnvToImGui = 104;
Mc5.EnvToImGui = 105;
Mc6.EnvToImGui = 106;
Mc7.EnvToImGui = 107;
Mc8.EnvToImGui = 108;
Mc1.LFO_PlayPos = 109;
Mc2.LFO_PlayPos = 110;
Mc3.LFO_PlayPos = 111;
Mc4.LFO_PlayPos = 112;
Mc5.LFO_PlayPos = 113;
Mc6.LFO_PlayPos = 114;
Mc7.LFO_PlayPos = 115;
Mc8.LFO_PlayPos = 116;







function ChangeRange(V1, V2 , Max)(
  V1 > V2 ? (

  (V1/Max) * V2 
  ): V2 > V1 ? (
    V2 *  V1
  );
);



function SendInfoBackToImGui()
(
  this.type =='step'?(
    (gmem[this.EnvToImGui] = SEQ[this.CurrentPos+1+64*(this.Macro-1)]*127);
    gmem[this.LFO_PlayPos] = this.CurrentPos;
  ):this.type =='env'?(
    gmem[this.EnvToImGui] = this.masr_do(midiamp)
  ):this.type =='Fol' ? (
    gmem[this.EnvToImGui] =  this.FOL_out*this.FOL_Gain*127
  ):this.type =='LFO'?(
   gmem[this.EnvToImGui] = this.LFOout;
   gmem[this.LFO_PlayPos] = this.CurrentPos;

  );
);


function CalculateLFO()(
  //this.CurrentPos = fmod (beat_position * (this.LFO_Spd ) , this.Lfo_Len  )  ;
  this.LFO_NodeCt = LFO[1*(this.Macro-1)*10000];
  loop (this.LFO_NodeCt  *11 ,
    N+=1;  // N means segment actually , there are 11 segments between each nodes
    X_idx = (this.Macro-1)*1000+N;
    Y_idx = (this.Macro-1)*1000+N+ this.LFO_NodeCt*11;


    x1 = LFO[X_idx];
    y1 = LFO[Y_idx];
    x2 = LFO[X_idx+1];
    y2 = LFO[Y_idx+1];
  

    p=this.CurrentPos/4;
    s = (x2 - x1)  ; // s for segment
    x1_howMuch  =  (x2-p) / s ;
    x2_HowMuch =   (s - (x2-p)) / s ; // (x1-(x1-p))/s;

 

    x1*4 < this.CurrentPos && x2*4 > this.CurrentPos ? (
      this.out =  ((y1*x1_howMuch) +(y2*x2_HowMuch) )  *this.LFO_Gain;

      this.LFOout = ((y1*x1_howMuch) +(y2*x2_HowMuch) ) * 127*this.LFO_Gain;

    ):x1< p && x2==0?(    // if playhead is beyond last node
      this.out = y1;
    );
    N == this.LFO_NodeCt ? (N=0);
  );

);

function CalculateLFO_Rel() local(S, Rpt, PlayPos,  )(

  this.bp += beat_per_block * this.LFO_Spd;
  this.CurrentPos =  min( this.bp ,this.Lfo_Len );


  
  loop (this.LFO_NodeCt  *11 ,
    N+=1;  // N means segment actually , there are 11 segments between each nodes
    X_idx = (this.Macro-1)*1000+N;
    Y_idx = (this.Macro-1)*1000+N+ this.LFO_NodeCt*11;


    x1 = LFO[X_idx];
    y1 = LFO[Y_idx];
    x2 = LFO[X_idx+1];
    y2 = LFO[Y_idx+1];

    this.Rel_Type==3 ? ( // if it's no jump
      AA_REL_NODE_VAL = LFO[(this.Macro-1)*1000+this.Rel_Node+ this.LFO_NodeCt*11];
      y1 = ChangeRange(this.Rel_V  , y1 , LFO[(this.Macro-1)*1000+this.Rel_Node*11+ this.LFO_NodeCt*11] );
      y2 = ChangeRange(this.Rel_V  , y2 , LFO[(this.Macro-1)*1000+this.Rel_Node*11+ this.LFO_NodeCt*11]);
    );
  

    p=this.CurrentPos/4;
    s = (x2 - x1)  ; // s for segment
    x1_howMuch  =  (x2-p) / s ;
    x2_HowMuch =   (s - (x2-p)) / s ; // (x1-(x1-p))/s;

 

    x1*4 < this.CurrentPos && x2*4 > this.CurrentPos ? (
      this.out =  ((y1*x1_howMuch) +(y2*x2_HowMuch) )  *this.LFO_Gain;

      this.LFOout = ((y1*x1_howMuch) +(y2*x2_HowMuch) ) * 127*this.LFO_Gain;

    ):x1< p && x2==0?(    // if playhead is beyond last node
      this.out = y1;
    );
    N == this.LFO_NodeCt ? (N=0);
  );




);






function DoMidiTriggeredActions()(
  this.EnvOrLoop == 1 ? (
      this.bp += beat_per_block * this.LFO_Spd;
      this.CurrentPos =  min( this.bp ,this.Lfo_Len )  ;
      this.CalculateLFO();
  );
);
function DoMidi_Release()(
  this.EnvOrLoop == 1 && (this.Rel_Type == 2 || this.Rel_Type == 3) ?(// if it's custom release
    this.CalculateLFO_Rel();
  );
);


function SetBpTo0 ()(
  this.EnvOrLoop == 1 ? (
    this.Legato == 0 ? ( 
      this.bp =  0;
    ):this.Legato == 1 && TotalNotesHeld == 1 ? ( // if this is the first note played, while not holding any other notes
      this.bp =  0;
    );
  );
);

function SetBpTo0_All()(
  Mc1.SetBpTo0();
  Mc2.SetBpTo0();
  Mc3.SetBpTo0();
  Mc4.SetBpTo0();
  Mc5.SetBpTo0();
  Mc6.SetBpTo0();
  Mc7.SetBpTo0();
  Mc8.SetBpTo0();
);


function SetBPToRel_Node()local (Rel_pos, Rel_V) (
  this.Rel_Type == 2 ||this.Rel_Type==3 ? ( //if it's custom release
    this.Rel_Type==3 ? (    // if it's no jump 
      this.Rel_V = this.Out ; // get value when note was released 
    );

    Rel_pos = LFO[(this.Macro-1)*1000+this.Rel_Node*11] * 4;

    this.CurrentPos< Rel_pos? ( // if 'playhead' hasn't reached the release node 
      this.Legato ==0 || (this.Legato ==1 && TotalNotesHeld == 0 ) ? (
        this.bp = Rel_pos;  // move playhead to release node 
      );
    );
  );

);

function SetBPToRel_Node_All()(
  Mc1.SetBPToRel_Node();
  Mc2.SetBPToRel_Node();
  Mc3.SetBPToRel_Node();
  Mc4.SetBPToRel_Node();
  Mc5.SetBPToRel_Node();
  Mc6.SetBPToRel_Node();
  Mc7.SetBPToRel_Node();
  Mc8.SetBPToRel_Node();


);

function LFO_Calc_Play_Pos ()(
  play_state == 1 ? ( // if playing

    this.bp += beat_per_block * this.LFO_Spd;
    this.CurrentPos =  fmod(this.bp + beat_per_block * this.LFO_Spd , this.Lfo_Len);

  ): play_state != 1 ? (   // if not playing
    this.bp =  beat_position * this.LFO_Spd ;
    this.CurrentPos = fmod(this.bp + beat_per_block * this.LFO_Spd, this.Lfo_Len);
  );
  


);


function SetMacroAttribute( x , y )
(
    Macro==1?(Mc1.FOL_Gain = y); 
    Macro==2?(Mc2.FOL_Gain = y); 
    Macro==3?(Mc3.FOL_Gain = y);
    Macro==4?(Mc4.FOL_Gain = y);
    Macro==5?(Mc5.FOL_Gain = y);
    Macro==6?(Mc6.FOL_Gain = y);
    Macro==7?(Mc7.FOL_Gain = y);
    Macro==8?(Mc8.FOL_Gain = y);
);

function CalculatMacroAmt() local (BipolarRange , MR )
(
  BipolarRange = 0;
  MR = ModRange;
  

  ModRange> 100 ? (     // if it's bipolar 
    BipolarRange = (ModRange- 100) ; 
    MR = (ModRange- 100) * 2;
  );
  


  this.type =='step'?(
    this.CurrentPos = (beat_position * this.SEQ_DNom) % this.SEQ_Leng ;
    this.out = SEQ[this.CurrentPos+1+64*(this.Macro-1)]  ;
    


  ):this.type =='env'?(

    this.masr_set_risetime(this.atk);
    this.masr_set_falltime(this.rel);
    this.out =  this.masr_do(midiamp);
    //trkGUID_Num === gmem[2]? (gmem[this.EnvToImGui] = this.masr_do(midiamp));



  ):this.type =='Fol' ? ( // if macro  is Follower 

    this.out = this.FOL_out*this.FOL_Gain  ;

  ):this.type=='LFO'    ?( // if type is LFO
    this.LFO_Gain_Auto != 0 ? ( 
      this.LFO_Gain = slider(Automate+this.LFO_Gain_Auto);
    );
    this.LFO_Spd_Auto!= 0 ? (
      this.LFO_Spd = max(pow( slider(Automate+this.LFO_Spd_Auto)*128 , 0.5), 0.125) ; // 0.5 is how exponential it is
    );

    this.EnvOrLoop == 0 ? (
      this.LFO_Calc_Play_Pos ();
      this.CalculateLFO();
    );

    

  ):(   //if type is macro
    this.Out = (this.Slider )   
  );
    



);



function SetTypeTo (T)
(
  Macro = gmem[5];
  Macro==1?(Mc1.type=T); 
  Macro==2?(Mc2.type=T);
  Macro==3?(Mc3.Type=T);
  Macro==4?(Mc4.Type=T);
  Macro==5?(Mc5.Type=T);
  Macro==6?(Mc6.Type=T);
  Macro==7?(Mc7.Type=T);
  Macro==8?(Mc8.Type=T);
);

function Check_If_Bipolar(ModAmt)
(
  ModAmt[i]> 100 ? (     // if it's bipolar 
    BipolarRange = (ModRange- 100) ; 
    MR = (ModRange- 100) * 2;
    BipolarRange; 
  );

);


function CalculateTotalOut ( i ) local(total , Bi_ofs, Bi_range, Amt, Bi_ofs)  // i is the track param number
(
  total = 0 ;
  Bi_ofs= 0;
  ModAmt[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt[i]- 100) ; 
    Amt = (ModAmt[i]- 100)*2 ;
  ):(Amt = ModAmt[i] ;);

  AA_AMT1 = Amt;
  AA_BI_OFS = Bi_ofs ; 
  ModAmt[i]  != 0 ? (total += Mc1.Out * Amt - Bi_ofs  ) ; 


  ModAmt2[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt2[i]- 100) ; 
    Amt = (ModAmt2[i]- 100)*2 ;
  ):(Amt = ModAmt2[i] ;);
  ModAmt2[i]  != 0 ? (total += Mc2.Out * Amt - Bi_ofs  ) ; 

  ModAmt3[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt3[i]- 100) ; 
    Amt = (ModAmt3[i]- 100)*2 ;
  ):(Amt = ModAmt3[i] ;);
  ModAmt3[i] != 0 ? (total += Mc3.Out *Amt - Bi_ofs) ; 

  ModAmt4[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt4[i]- 100) ; 
    Amt = (ModAmt4[i]- 100)*2 ;
  ):(Amt = ModAmt4[i] ;);
  ModAmt4[i] != 0 ? (total += Mc4.Out *Amt - Bi_ofs) ; 

  ModAmt5[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt5[i]- 100) ; 
    Amt = (ModAmt5[i]- 100)*2 ;
  ):(Amt = ModAmt5[i] ;);
  ModAmt5[i] != 0 ? (total += Mc5.Out *Amt- Bi_ofs) ; 

  ModAmt6[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt6[i]- 100) ; 
    Amt = (ModAmt6[i]- 100)*2 ;
  ):(Amt = ModAmt6[i] ;);
  ModAmt6[i] != 0 ? (total += Mc6.Out *Amt - Bi_ofs) ; 

  ModAmt7[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt7[i]- 100) ; 
    Amt = (ModAmt7[i]- 100)*2 ;
  ):(Amt = ModAmt7[i] ;);
  ModAmt7[i] != 0 ? (total += Mc7.Out *Amt- Bi_ofs) ; 

  ModAmt8[i]> 100 ? (     // if it's bipolar 
    Bi_ofs = (ModAmt8[i]- 100) ; 
    Amt = (ModAmt8[i]- 100)*2 ;
  ):(Amt = ModAmt8[i] ;);
  ModAmt8[i] != 0 ? (total += Mc8.Out *Amt - Bi_ofs) ; 

  total *127 ; 
);

@slider
Mc1.Slider = slider1;
Mc2.Slider = slider2;
Mc3.Slider = slider3;
Mc4.Slider = slider4;
Mc5.Slider = slider5;
Mc6.Slider = slider6;
Mc7.Slider = slider7;
Mc8.Slider = slider8;



@sample 


Mc1.FOL_out  = Mc1.follow_do((spl0+spl1));
Mc2.FOL_out  = Mc2.follow_do((spl0+spl1));
Mc3.FOL_out  = Mc3.follow_do((spl0+spl1));
Mc4.FOL_out  = Mc4.follow_do((spl0+spl1));
Mc5.FOL_out  = Mc5.follow_do((spl0+spl1));
Mc6.FOL_out  = Mc6.follow_do((spl0+spl1));
Mc7.FOL_out  = Mc7.follow_do((spl0+spl1));
Mc8.FOL_out  = Mc8.follow_do((spl0+spl1));





@block
/*ABAABABA = 123;
A11001 = a[11001];
A11000 = a[11000];
A_gmem1 = gmem[1];
A_gmem2_DIY_ID = gmem[2];
A_gmem7 = gmem[7];
A_gmem11000 = gmem[11000];
A_gmem11001 = gmem[11001];
A_gmem11002 = gmem[11002];
A_gmem3 = gmem[3];
A_gmem4_Mode = gmem[4];
A_gmem6 = gmem[6];
A_gmem5 = gmem[5];
A_gmem_2001 = gmem[2001];*/
Automate = 16; // first one will be 17 

// Calculate current play position
  beat_per_spl = tempo / (srate * 60);
  beat_per_block = beat_per_spl * samplesblock;

  play_state == 1  && playstate_started == 0  ? (
    //bp = beat_position;
    playstate_started = 1 ; 
  ); 

  



Sel_Trk_GUID_num = gmem[2];
//This will only execute once when playback starts
play_state === 0 ? (   
sendMidi = 0;
);  
play_state != 0 && sendMidi === 0 ? (
 
midisend(0, $x81, 30, 127); //Channel is the numb after $x9
sendMidi= 1;
);
// ----------------------------------------

//â–¼Send Midi Msg only when slider is moved or automated
Sldr9!=Slider9?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 1/*Which Note*/  , Slider9));
Sldr9=Slider9;

Sldr10!=Slider10?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 2/*Which Note*/  , Slider10));
Sldr10=Slider10;

Sldr11!=Slider11?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 3/*Which Note*/  , Slider11));
Sldr11=Slider11;

Sldr12!=Slider12?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 4/*Which Note*/  , Slider12));
Sldr12=Slider12;

Sldr13!=Slider13?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 5/*Which Note*/  , Slider13));
Sldr13=Slider13;

Sldr14!=Slider14?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 6/*Which Note*/  , Slider14));
Sldr14=Slider14;

Sldr15!=Slider15?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 7/*Which Note*/  , Slider15));
Sldr15=Slider15;

Sldr16!=Slider16?( midisend(0, $xAF/*AfterTouch, 16th Chan*/, 8/*Which Note*/  , Slider16));
Sldr16=Slider16;


mode= gmem[4];


//if user tweaking track that matches trkGUID
DIY_ID === gmem[2]? (
  Macro = gmem[5];
  mode ==1?(   // if User is right-dragging on param in ImGui...
    P.Inst = gmem[3];    
    Param = gmem[6];
    Macro = gmem[5];
    a[Param+ Macro*1000] = gmem[Param+ Macro*1000];
        
  );
  mode ==2?(   // if User is adjusting atk...  
    gmem[9] !=0?(Mc1.atk = gmem[9]); 
    gmem[11]!=0?(Mc2.atk = gmem[11]);  
    gmem[13]!=0?(Mc3.atk = gmem[13]);
    gmem[15]!=0?(Mc4.atk = gmem[15]);
    gmem[17]!=0?(Mc5.atk = gmem[17]);
    gmem[19]!=0?(Mc6.atk = gmem[19]);
    gmem[21]!=0?(Mc7.atk = gmem[21]);
    gmem[23]!=0?(Mc8.atk = gmem[23]);
    SetTypeTo ('env');                    
  );
  mode ==3?(   // if User is adjusting Release...
      gmem[10]!=0?(Mc1.Rel=gmem[10]);
      gmem[12]!=0?(Mc2.Rel=gmem[12]);
      gmem[14]!=0?(Mc3.Rel=gmem[14]);
      gmem[16]!=0?(Mc4.Rel=gmem[16]);
      gmem[18]!=0?(Mc5.Rel=gmem[18]);
      gmem[20]!=0?(Mc6.Rel=gmem[20]);
      gmem[22]!=0?(Mc7.Rel=gmem[22]);
      gmem[24]!=0?(Mc8.Rel=gmem[22]);
      SetTypeTo ('env');            
      );
  mode ==4?(   //if user ctrl-r-click and change type to Env...
    SetTypeTo ('env');
      );
  mode ==5? (   
    SetTypeTo ('Mc');
     );
  mode == 6? (  
    SetTypeTo ('step');
  );
  mode == 7 ? (  // if user is tweaking a step's Value
    SetTypeTo ('step');
    WhichStep= gmem[113]; 
    Macro==1?(
      SEQ[WhichStep]= gmem[112]; //writes seq value from table slot 20001~20048
    ):Macro==2?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64]= gmem[112];  
    ):Macro==3?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*2]= gmem[112];  
    ):Macro==4?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*3]= gmem[112];  
    ):Macro==5?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*4]= gmem[112];  
    ):Macro==6?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*5]= gmem[112];  
    ):Macro==7?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*6]= gmem[112];  
    ):Macro==8?(    // //writes seq value from table slot 20065~20129
      SEQ[WhichStep+64*7]= gmem[112];  
    );
  
  );

  mode == 8 ? (// if user is changing note length...
    Macro = gmem[5];
    Macro==1?( //if user is tweaking macro 1
      gmem[9] != 0  ? (Mc1.SEQ_Leng = gmem[9];     gmem[9] = 0) ; 
      gmem[10] != 0 ? (Mc1.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==2?(
      gmem[9] != 0  ? (Mc2.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc2.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==3?(
      gmem[9] != 0  ? (Mc3.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc3.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==4?(
      gmem[9] != 0  ? (Mc4.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc4.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==5?(
      gmem[9] != 0  ? (Mc5.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc5.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==6?(
      gmem[9] != 0  ? (Mc6.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc6.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==7?(
      gmem[9] != 0  ? (Mc7.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc7.SEQ_DNom = gmem[10];    gmem[10] = 0);
    ):Macro==8?(
      gmem[9] != 0  ? (Mc8.SEQ_Leng = gmem[9];     gmem[9] = 0); 
      gmem[10] != 0 ? (Mc8.SEQ_DNom = gmem[10];    gmem[10] = 0);
    );
  );

  mode == 9? (
    SetTypeTo('Fol')

  );

  mode == 10 ? (
     // sets smoothness
    Macro = gmem[5];
    Macro==1?(Mc1.follow_set_freq(gmem[9]));
    Macro==2?(Mc2.follow_set_freq(gmem[9]));
    Macro==3?(Mc3.follow_set_freq(gmem[9]));
    Macro==4?(Mc4.follow_set_freq(gmem[9]));
    Macro==5?(Mc5.follow_set_freq(gmem[9]));
    Macro==6?(Mc6.follow_set_freq(gmem[9]));
    Macro==7?(Mc7.follow_set_freq(gmem[9]));
    Macro==8?(Mc8.follow_set_freq(gmem[9]));

  );
  mode == 11 ? (
    Macro==1?(Mc1.FOL_Gain = gmem[9];); 
    Macro==2?(Mc2.FOL_Gain = gmem[9];); 
    Macro==3?(Mc3.FOL_Gain = gmem[9];);
    Macro==4?(Mc4.FOL_Gain = gmem[9];);
    Macro==5?(Mc5.FOL_Gain = gmem[9];);
    Macro==6?(Mc6.FOL_Gain = gmem[9];);
    Macro==7?(Mc7.FOL_Gain = gmem[9];);
    Macro==8?(Mc8.FOL_Gain = gmem[9];);
  );
  mode == 12?(  // if user is tweaking lfo speed
    SetTypeTo('LFO');
    Macro = gmem[5];
    Macro==1?(Mc1.LFO_Spd = gmem[9];); 
    Macro==2?(Mc2.LFO_Spd = gmem[9];); 
    Macro==3?(Mc3.LFO_Spd = gmem[9];);
    Macro==4?(Mc4.LFO_Spd = gmem[9];);
    Macro==5?(Mc5.LFO_Spd = gmem[9];);
    Macro==6?(Mc6.LFO_Spd = gmem[9];);
    Macro==7?(Mc7.LFO_Spd = gmem[9];);
    Macro==8?(Mc8.LFO_Spd = gmem[9];);
  );
  mode == 13?( //if user is adjusting LFO Length
    SetTypeTo('LFO');
    Macro==1?(Mc1.LFO_Len = gmem[9];); 
    Macro==2?(Mc2.LFO_Len = gmem[9];); 
    Macro==3?(Mc3.LFO_Len = gmem[9];);
    Macro==4?(Mc4.LFO_Len = gmem[9];);
    Macro==5?(Mc5.LFO_Len = gmem[9];);
    Macro==6?(Mc6.LFO_Len = gmem[9];);
    Macro==7?(Mc7.LFO_Len = gmem[9];);
    Macro==8?(Mc8.LFO_Len = gmem[9];);
  );
  mode == 14?(   // if user is adjusting LFO Gain
    SetTypeTo('LFO');
    Macro==1?(Mc1.LFO_Gain = gmem[9];); 
    Macro==2?(Mc2.LFO_Gain = gmem[9];); 
    Macro==3?(Mc3.LFO_Gain = gmem[9];);
    Macro==4?(Mc4.LFO_Gain = gmem[9];);
    Macro==5?(Mc5.LFO_Gain = gmem[9];);
    Macro==6?(Mc6.LFO_Gain = gmem[9];);
    Macro==7?(Mc7.LFO_Gain = gmem[9];);
    Macro==8?(Mc8.LFO_Gain = gmem[9];);
  );
  

  mode == 15?(  // if user changing LFO Shape
    SetTypeTo('LFO');
    Pts_Count = gmem[6];
    Macro = gmem[5];
    LFO[1*(Macro-1)*10000] = Pts_Count;  // 30000 = lfo 1's pt count,  40000 = lfo 2's pt count
    i=0;
    loop(Pts_Count,
      i+=1;
      X_idx = (Macro-1)*1000+i;   //LFO=30000 + ( LFO 1 = 1~ 1000) or (LFO 2 = 1001 ~ 2000)... etc
      Y_idx = (Macro-1)*1000+ i + Pts_Count*11 ; // table slot for Y Coordinates, the +i +Pts_Count*11 should ensure slots don't overlap with X

      LFO[X_idx]= gmem[1000+i];
      LFO[Y_idx]= gmem[2000+i];
    );
     
    i=0;
    
   /*  Macro==1?( Mc1.blosc_set_type(gmem[10])); 
    Macro==2?( Mc2.blosc_set_type(gmem[10])); 
    Macro==3?( Mc3.blosc_set_type(gmem[10]));
    Macro==4?( Mc4.blosc_set_type(gmem[10]));
    Macro==5?( Mc5.blosc_set_type(gmem[10]));
    Macro==6?( Mc6.blosc_set_type(gmem[10]));
    Macro==7?( Mc7.blosc_set_type(gmem[10]));
    Macro==8?( Mc8.blosc_set_type(gmem[10])); */
  );

  mode ==16?(  // if user set LFO_Gain as automatable parameter...
    AutomatedPrm_Num = gmem[9];
    Macro==1?(Mc1.LFO_Gain_Auto = AutomatedPrm_Num;); 
    Macro==2?(Mc2.LFO_Gain_Auto = AutomatedPrm_Num;); 
    Macro==3?(Mc3.LFO_Gain_Auto = AutomatedPrm_Num;);
    Macro==4?(Mc4.LFO_Gain_Auto = AutomatedPrm_Num;);
    Macro==5?(Mc5.LFO_Gain_Auto = AutomatedPrm_Num;);
    Macro==6?(Mc6.LFO_Gain_Auto = AutomatedPrm_Num;);
    Macro==7?(Mc7.LFO_Gain_Auto = AutomatedPrm_Num;);
    Macro==8?(Mc8.LFO_Gain_Auto = AutomatedPrm_Num;);
  );
  mode == 17 ? ( 
    AutomatedPrm_Num = gmem[9];   // if set LFO speed as automatable paramter
    Macro==1?(Mc1.LFO_Spd_Auto = AutomatedPrm_Num;); 
    Macro==2?(Mc2.LFO_Spd_Auto = AutomatedPrm_Num;); 
    Macro==3?(Mc3.LFO_Spd_Auto = AutomatedPrm_Num;);
    Macro==4?(Mc4.LFO_Spd_Auto = AutomatedPrm_Num;);
    Macro==5?(Mc5.LFO_Spd_Auto = AutomatedPrm_Num;);
    Macro==6?(Mc6.LFO_Spd_Auto = AutomatedPrm_Num;);
    Macro==7?(Mc7.LFO_Spd_Auto = AutomatedPrm_Num;);
    Macro==8?(Mc8.LFO_Spd_Auto = AutomatedPrm_Num;);
  );
  mode == 18? ( // if user set LFO's type (loop or envelope)
    Macro = gmem[5];
    Macro==1?(Mc1.EnvOrLoop = gmem[9]); 
    Macro==2?(Mc2.EnvOrLoop = gmem[9]); 
    Macro==3?(Mc3.EnvOrLoop = gmem[9]);
    Macro==4?(Mc4.EnvOrLoop = gmem[9]);
    Macro==5?(Mc5.EnvOrLoop = gmem[9]);
    Macro==6?(Mc6.EnvOrLoop = gmem[9]);
    Macro==7?(Mc7.EnvOrLoop = gmem[9]);
    Macro==8?(Mc8.EnvOrLoop = gmem[9]);
  );
  mode == 19 ? ( // if user set LFO Release type 
    // type 0 = latch , type 1 = simple , type 2 = custom
    Macro==1?(Mc1.Rel_Type = gmem[9]); 
    Macro==2?(Mc2.Rel_Type = gmem[9]); 
    Macro==3?(Mc3.Rel_Type = gmem[9]);
    Macro==4?(Mc4.Rel_Type = gmem[9]);
    Macro==5?(Mc5.Rel_Type = gmem[9]);
    Macro==6?(Mc6.Rel_Type = gmem[9]);
    Macro==7?(Mc7.Rel_Type = gmem[9]);
    Macro==8?(Mc8.Rel_Type = gmem[9]);
  );
  mode == 20 ? ( // if user set LFO Release Node 
    Macro==1?(Mc1.Rel_Node = gmem[9]); 
    Macro==2?(Mc2.Rel_Node = gmem[9]); 
    Macro==3?(Mc3.Rel_Node = gmem[9]);
    Macro==4?(Mc4.Rel_Node = gmem[9]);
    Macro==5?(Mc5.Rel_Node = gmem[9]);
    Macro==6?(Mc6.Rel_Node = gmem[9]);
    Macro==7?(Mc7.Rel_Node = gmem[9]);
    Macro==8?(Mc8.Rel_Node = gmem[9]);

  );
  mode == 21 ? (// if user set envelope to Legato
    Macro==1?(Mc1.Legato = gmem[9]); 
    Macro==2?(Mc2.Legato = gmem[9]); 
    Macro==3?(Mc3.Legato = gmem[9]);
    Macro==4?(Mc4.Legato = gmem[9]);
    Macro==5?(Mc5.Legato = gmem[9]);
    Macro==6?(Mc6.Legato = gmem[9]);
    Macro==7?(Mc7.Legato = gmem[9]);
    Macro==8?(Mc8.Legato = gmem[9]);

  );

  
      
  gmem[7] != 0?( // if user uses Imgui to tweak param...
    P_Id = gmem[7];
    P_OrigV[P_Id]= gmem[11000+P_Id];
    what=gmem[8];
    gmem[8] != 0?( // if paramV + Mod is over 1...
      a[Param+ Macro*1000] = gmem[Param+ Macro*1000]
    );
   
  );





); // --------------------- End of if track is selected -----------------------




midi_bus=Cont_ID+15; // 0-based so 1 = bus 2
while (midirecv(offset, msg1, msg2, msg3)) (
  // get noteons and noteoffs from all channels
  
  midi_bus=Cont_ID+15; // 0-based so 1 = bus 2
  (msg1 & $xF0) == $x90 || (msg1 & $xF0) == $x80 ? (
      msg3 != 0 ? (
        // noteon 
        midinote = msg2;
        NoteOn = 1  ;
        // msg3 == Velocity
        midiamp =  128; // /msg33   // if you want Velocity involved use msg 3
        TotalNotesHeld+=1;
        SetBpTo0_All ();
        midisend(offset,msg1,msg2,msg3);
      ) : (
        // noteoff
        msg2 == midinote ? midiamp = 0;
        TotalNotesHeld -=1;
        SetBPToRel_Node_All();  
        NoteOn = 0;
        midisend(offset,msg1,msg2,msg3);
      );
  ) : (
    
      // passthrough other events
      midisend(offset,msg1,msg2,msg3);
  );
);

NoteOn ? (

  Mc1.DoMidiTriggeredActions();
  Mc2.DoMidiTriggeredActions();
  Mc3.DoMidiTriggeredActions();
  Mc4.DoMidiTriggeredActions();
  Mc5.DoMidiTriggeredActions();
  Mc6.DoMidiTriggeredActions();
  Mc7.DoMidiTriggeredActions();
  Mc8.DoMidiTriggeredActions();
):(
  Mc1.DoMidi_Release();
  Mc2.DoMidi_Release();
  Mc3.DoMidi_Release();
  Mc4.DoMidi_Release();
  Mc5.DoMidi_Release();
  Mc6.DoMidi_Release();
  Mc7.DoMidi_Release();
  Mc8.DoMidi_Release();

);

Mc1.CalculatMacroAmt();
Mc2.CalculatMacroAmt();
Mc3.CalculatMacroAmt();
Mc4.CalculatMacroAmt();
Mc5.CalculatMacroAmt();
Mc6.CalculatMacroAmt();
Mc7.CalculatMacroAmt();
Mc8.CalculatMacroAmt();
 

i=1; // Main Send Midi    
while ( i <= P.Inst)(
  SendAmt = min( P_OrigV[i]*127 + CalculateTotalOut ( i )  , 127) ;
  AAAABC = CalculateTotalOut ( i );
  midisend(0, $xBf, i, SendAmt);
      
  i+=1;
);


///  ---------------- Send info back to ImGui ------------------ 
DIY_ID === gmem[2]? (
  Mc1.SendInfoBackToImGui();
  Mc2.SendInfoBackToImGui();
  Mc3.SendInfoBackToImGui();
  Mc4.SendInfoBackToImGui();
  Mc5.SendInfoBackToImGui();
  Mc6.SendInfoBackToImGui();
  Mc7.SendInfoBackToImGui();
  Mc8.SendInfoBackToImGui();
);
  


playstate_started ? ( playstate_started = 0 );




//------------------------------------------------------------------------------------------------


midi_bus=Cont_ID+15; // 0-based so 1 = bus 2
while (midirecv(offset, msg1, msg2, msg3)) (

midi_bus=Cont_ID+15; // 0-based so 1 = bus 2
    // get noteons and noteoffs from all channels
    (msg1 & $xF0) == $x90 || (msg1 & $xF0) == $x80 ? (
        msg3 != 0 ? (
            // noteon 
            midinote = msg2;
            // Normalizes amplitude value
            midiamp = msg3 / 94;
            time = time_precise();
            

            
        ) : (
            // noteoff
            
            msg2 == midinote ? midiamp = 0;
        );
    ) : (
        // passthrough other events
        midisend(offset,msg1,msg2,msg3);
    );
);


play_state == 0 || play_state == 2 || play_state ==6 ? (
  playstate_started = 0 ;
);

/*
@gfx
gfx_set(1.0);
gfx_x = gfx_y = 8;
i = 0;
loop(10,
gfx_printf("%d = %g", i, gmem[i]);
  i += 1;
);